// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
)

const (
	toLower = 'a' - 'A'
)

func main() {
	var hex2intTable = func() [256]byte {
		var b [256]byte
		for i := 0; i < 256; i++ {
			c := byte(16)
			if i >= '0' && i <= '9' {
				c = byte(i) - '0'
			} else if i >= 'a' && i <= 'f' {
				c = byte(i) - 'a' + 10
			} else if i >= 'A' && i <= 'F' {
				c = byte(i) - 'A' + 10
			}
			b[i] = c
		}
		return b
	}()

	var toLowerTable = func() [256]byte {
		var a [256]byte
		for i := 0; i < 256; i++ {
			c := byte(i)
			if c >= 'A' && c <= 'Z' {
				c += toLower
			}
			a[i] = c
		}
		return a
	}()

	var toUpperTable = func() [256]byte {
		var a [256]byte
		for i := 0; i < 256; i++ {
			c := byte(i)
			if c >= 'a' && c <= 'z' {
				c -= toLower
			}
			a[i] = c
		}
		return a
	}()

	var quotedArgShouldEscapeTable = func() [256]byte {
		// According to RFC 3986 ยง2.3
		var a [256]byte
		for i := 0; i < 256; i++ {
			a[i] = 1
		}

		// ALPHA
		for i := int('a'); i <= int('z'); i++ {
			a[i] = 0
		}
		for i := int('A'); i <= int('Z'); i++ {
			a[i] = 0
		}

		// DIGIT
		for i := int('0'); i <= int('9'); i++ {
			a[i] = 0
		}

		// Unreserved characters
		a[int('-')] = 0
		a[int('_')] = 0
		a[int('.')] = 0
		a[int('~')] = 0

		return a
	}()

	var quotedPathShouldEscapeTable = func() [256]byte {
		// The implementation here equal to net/url shouldEscape(s, encodePath)
		//
		// The RFC allows : @ & = + $ but saves / ; , for assigning
		// meaning to individual path segments. This package
		// only manipulates the path as a whole, so we allow those
		// last three as well. That leaves only ? to escape.
		var a = quotedArgShouldEscapeTable

		// '$', '&', '+', ',', '/', ':', ';', '=', '@'
		a[int('$')] = 0
		a[int('&')] = 0
		a[int('+')] = 0
		a[int(',')] = 0
		a[int('/')] = 0
		a[int(':')] = 0
		a[int(';')] = 0
		a[int('=')] = 0
		a[int('@')] = 0

		return a
	}()

	tables := []string{"hex2intTable", "toLowerTable", "toUpperTable", "quotedArgShouldEscapeTable", "quotedPathShouldEscapeTable"}
	m := map[string][256]byte{
		"hex2intTable":                hex2intTable,
		"toLowerTable":                toLowerTable,
		"toUpperTable":                toUpperTable,
		"quotedArgShouldEscapeTable":  quotedArgShouldEscapeTable,
		"quotedPathShouldEscapeTable": quotedPathShouldEscapeTable,
	}

	w := new(bytes.Buffer)
	w.WriteString(pre)
	for _, k := range tables {
		v := m[k]
		tmp := make([]byte, 256)
		for i := 0; i < 256; i++ {
			tmp[i] = v[i]
		}
		fmt.Fprintf(w, table, k, string(tmp))
	}

	out, err := format.Source(w.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err := ioutil.WriteFile("bytesconv_table.go", out, 0660); err != nil {
		log.Fatal(err)
	}

}

const pre = `// Code generated by go run bytesconv_table_gen.go; DO NOT EDIT.
// See bytesconv_table_gen.go for more information about these tables.

package fasthttp

`

const table = `const %s = %#v
`
